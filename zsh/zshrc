

export ZSH="$HOME/.oh-my-zsh"
export RCLONE_CONFIG_PASS="21.09mariana_manuel"
export TERMINAL=ghostty

ZSH_THEME="jovial"




# Uncomment one of the following lines to change the auto-update behavior
# zstyle ':omz:update' mode disabled  # disable automatic updates
# zstyle ':omz:update' mode auto      # update automatically without asking
# zstyle ':omz:update' mode reminder  # just remind me to update when it's time

# Uncomment the following line to change how often to auto-update (in days).
# zstyle ':omz:update' frequency 13

# Uncomment the following line if pasting URLs and other text is messed up.
# DISABLE_MAGIC_FUNCTIONS="true"

# Uncomment the following line to disable colors in ls.
# DISABLE_LS_COLORS="true"

# Uncomment the following line to disable auto-setting terminal title.
# DISABLE_AUTO_TITLE="true"

# Uncomment the following line to enable command auto-correction.
ENABLE_CORRECTION="true"

# Uncomment the following line to display red dots whilst waiting for completion.
# You can also set it to another string to have that shown instead of the default red dots.
# e.g. COMPLETION_WAITING_DOTS="%F{yellow}waiting...%f"
# Caution: this setting can cause issues with multiline prompts in zsh < 5.7.1 (see #5765)
# COMPLETION_WAITING_DOTS="true"

# Uncomment the following line if you want to disable marking untracked files
# under VCS as dirty. This makes repository status check for large repositories
# much, much faster.
# DISABLE_UNTRACKED_FILES_DIRTY="true"

# Uncomment the following line if you want to change the command execution time
# stamp shown in the history command output.
# You can set one of the optional three formats:
# "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
# or set a custom format using the strftime function format specifications,
# see 'man strftime' for details.
HIST_STAMPS="mm/dd/yyyy"

plugins=(git zsh-autosuggestions zsh-syntax-highlighting)

source $ZSH/oh-my-zsh.sh

export LANG=en_US.UTF-8

if [[ -n $SSH_CONNECTION ]]; then
  export EDITOR='vim'
else
  export EDITOR='nvim'
fi


config() {
  cd ~/.config/"$1" || echo "config not found $1"
}

find_venv_root() {
    local dir="$1"
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/.venv/bin/activate" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

cd() {
    # Cambiar de directorio
    builtin cd "$@" || return
    
    # Buscar el directorio raÃ­z del venv desde el directorio actual
    local new_venv_root
    new_venv_root=$(find_venv_root "$PWD")
    
    # Determinar quÃ© hacer
    if [[ -n "$new_venv_root" ]]; then
        # Hay un venv en algÃºn directorio padre
        
        # Si no tenemos venv activo O el venv activo es diferente
        if [[ -z "$VIRTUAL_ENV" ]] || \
           [[ "$VIRTUAL_ENV" != "$new_venv_root/.venv" ]]; then
            # Cambiar al nuevo venv
            [[ -n "$VIRTUAL_ENV" ]] && deactivate 2>/dev/null
            source "$new_venv_root/.venv/bin/activate"
            export VENV_PROJECT_ROOT="$new_venv_root"
        fi
        # Si ya estamos en el mismo venv, no hacer nada
    
    else
        # No hay venv en ningÃºn directorio padre
        
        # Solo desactivar si estamos completamente fuera del proyecto
        if [[ -n "$VIRTUAL_ENV" ]] && [[ -n "$VENV_PROJECT_ROOT" ]]; then
            # Â¿EstÃ¡ PWD dentro de VENV_PROJECT_ROOT?
            # Usando :t (tail) para comparar
            if [[ "${PWD##$VENV_PROJECT_ROOT/}" == "$PWD" ]]; then
                # No estÃ¡ dentro, desactivar
                deactivate 2>/dev/null
                unset VENV_PROJECT_ROOT
            fi
            # Si estÃ¡ dentro, mantener activo
        fi
    fi
}

bwlist() {
    echo ""
    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    echo "â”‚                         ğŸ“¦ BITWARDEN VAULT ITEMS                          â”‚"
    echo "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"

    bw list items | jq -r '.[] | "\(.name)|\(.login.username // "â€”")|\(
        if .login.uris then 
            .login.uris[0].uri // "â€”" 
        else 
            "â€”" 
        end
    )"' | 
    awk -F'|' '
    BEGIN {
        printf "â”‚ \033[1;36m%-25s\033[0m â”‚ \033[1;33m%-20s\033[0m â”‚ \033[1;34m%-35s\033[0m â”‚\n", 
        "Nombre", "Usuario", "URL"
        print "â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤"
    }
    {
        # Truncar strings largos
        name = length($1) > 24 ? substr($1,1,21) "..." : $1
        user = length($2) > 19 ? substr($2,1,16) "..." : $2
        url = length($3) > 34 ? substr($3,1,31) "..." : $3
        
        printf "â”‚ %-25s â”‚ %-20s â”‚ %-35s â”‚\n", name, user, url
    }
    END {
        print "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
    }'
}

bwfind() {
    # Verificar que se proporcione un nombre
    if [[ -z "$1" ]]; then
        echo "âŒ Uso: bwfind <nombre-del-item>"
        echo "Ejemplo: bwfind github"
        echo ""
        echo "ğŸ“Œ Para buscar parcialmente: bwfind gith"
        return 1
    fi
    
    # Desbloquear vault si es necesario
    if ! bw login --check &>/dev/null; then
        echo "ğŸ”’ Vault bloqueado. Iniciando desbloqueo..."
        bwul 2>/dev/null || {
            echo "âŒ No se pudo desbloquear el vault"
            return 1
        }
    fi
    
    local search_term="$1"
    
    # Buscar items (case insensitive)
    echo "ğŸ” Buscando: '$search_term'..."
    echo ""
    
    # Buscar y mostrar todos los matches
    local items_json
    items_json=$(bw list items --search "$search_term" 2>/dev/null)
    
    if [[ -z "$items_json" || "$items_json" == "[]" ]]; then
        echo "âŒ No se encontraron items con: '$search_term'"
        echo ""
        echo "ğŸ“‹ Items disponibles:"
        bw list items | jq -r '.[] | "  â€¢ \(.name)"' | head -10
        return 1
    fi
    
    # Contar resultados
    local count=$(echo "$items_json" | jq '. | length')
    
    if [[ $count -gt 1 ]]; then
        echo "ğŸ“– Encontrados $count items:"
        echo ""
        
        echo "$items_json" | jq -r '.[] | "  \(.id) | \(.name) | \(.login.username // "sin usuario")"'
        echo ""
        echo "â„¹ï¸  Usa el ID completo para ver un item especÃ­fico:"
        echo "   bwfind-by-id <id>"
        return 0
    fi
    
    # Si solo hay un resultado, mostrar toda la info
    local item_id=$(echo "$items_json" | jq -r '.[0].id')
    local item_name=$(echo "$items_json" | jq -r '.[0].name')
    
    echo "================================================"
    echo "ğŸ” $(tput bold)$item_name$(tput sgr0)"
    echo "================================================"
    
    # Obtener informaciÃ³n completa
    local full_item
    full_item=$(bw get item "$item_id" 2>/dev/null)
    
    if [[ -z "$full_item" ]]; then
        echo "âŒ No se pudo obtener la informaciÃ³n del item"
        return 1
    fi
    
    # Mostrar informaciÃ³n bÃ¡sica
    echo "$full_item" | jq -r '
        "ğŸ“ " + .name + 
        "\nğŸ‘¤ Usuario: " + (.login.username // "N/A") + 
        "\nğŸ“§ Correo: " + (.login.username // "N/A") + 
        "\nğŸ”— URL: " + (.login.uris[0].uri // "N/A") +
        "\nğŸ†” ID: " + .id
    '
    
    # Mostrar notas si existen
    local notes=$(echo "$full_item" | jq -r '.notes // ""')
    if [[ -n "$notes" && "$notes" != "null" ]]; then
        echo ""
        echo "ğŸ“‹ Notas:"
        echo "$notes" | sed 's/^/  /'
    fi
    
    # Mostrar campos personalizados si existen
    local custom_fields=$(echo "$full_item" | jq -r '.fields // []')
    if [[ "$custom_fields" != "[]" ]]; then
        echo ""
        echo "ğŸ·ï¸  Campos personalizados:"
        echo "$custom_fields" | jq -r '.[] | "  \(.name): \(.value)"'
    fi
    
    # Obtener y mostrar la CONTRASEÃ‘A
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    echo "ğŸ”“ $(tput bold)CONTRASEÃ‘A:$(tput sgr0)"
    
    local password
    password=$(bw get password "$item_id" 2>/dev/null)
    
    if [[ -n "$password" ]]; then
        echo "$password"
        echo ""
        
        # Preguntar si copiar al portapapeles
        echo "ğŸ“‹ Â¿Copiar contraseÃ±a al portapapeles? (s/N): "
        read -k 1 -r
        echo ""
        
        if [[ $REPLY =~ ^[SsYy]$ ]]; then
            if echo -n "$password" | xclip -selection clipboard 2>/dev/null; then
                echo "âœ… ContraseÃ±a copiada! (xclip)"
            elif echo -n "$password" | wl-copy 2>/dev/null; then
                echo "âœ… ContraseÃ±a copiada! (wl-copy)"
            elif echo -n "$password" | pbcopy 2>/dev/null; then
                echo "âœ… ContraseÃ±a copiada! (pbcopy)"
            else
                echo "âš ï¸  No se pudo copiar al portapapeles"
                echo "   La contraseÃ±a estÃ¡ arriba â†‘"
            fi
        fi
    else
        echo "âŒ No se pudo obtener la contraseÃ±a"
    fi
    
    echo ""
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
}



alias zshconfig="nvim ~/.zshrc"
alias ohmyzsh="nvim ~/.oh-my-zsh"
alias act="source .venv/bin/activate"
alias nenv="uv init"
alias ls='exa --icons -F -H --group-directories-first --git -1'   
alias vi="nvim"
alias view_content="ls *"
alias open="spf $1"
alias cat='bat --theme="Catppuccin Mocha"'

alias activateAnimations="gsettings set org.gnome.desktop.interface enable-animations true"
alias deactivateAnimations="gsettings set org.gnome.desktop.interface enable-animations false"


alias startDocker="sudo systemctl start docker && sudo systemctl start docker.socket"
alias stopDocker="sudo systemctl stop docker && sudo systemctl stop docker.socket"
alias startPostgre="docker compose -f ~/docker-dev/docker-compose.yml start postgres"
alias stopPostgre="docker compose -f ~/docker-dev/docker-compose.yml stop postgres"
alias startMysql="docker compose -f ~/docker-dev/docker-compose.yml start mysql"
alias stopMysql="docker compose -f ~/docker-dev/docker-compose.yml stop mysql"

alias view_graph="obsidian.bin && brave ~/output/vault_graph.html"
alias cls="clear"
alias py="python"


# Git Aliases
alias gs="git status"
alias ga="git add"
alias gc="git commit"
alias gca="git commit --amend --no-edit"
alias gp="git push"
alias gu="git pull"
alias gcln="git clone"

ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#d7c3ba'
eval "$(dircolors -b ~/.dircolors)"
eval "$(zoxide init zsh)"
export PATH=$HOME/.local/bin:$PATH

# bun completions
[ -s "/home/fede/.bun/_bun" ] && source "/home/fede/.bun/_bun"

# bun
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
export HIGHLIGHT_STYLE="darkplus"

export GPG_TTY=$(tty)
